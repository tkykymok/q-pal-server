// Code generated by SQLBoiler 4.14.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Reservation is an object representing the database table.
type Reservation struct {
	ReservationID        int       `boil:"reservation_id" json:"reservation_id" toml:"reservation_id" yaml:"reservation_id"`
	CustomerID           int       `boil:"customer_id" json:"customer_id" toml:"customer_id" yaml:"customer_id"`
	StoreID              int       `boil:"store_id" json:"store_id" toml:"store_id" yaml:"store_id"`
	StaffID              null.Int  `boil:"staff_id" json:"staff_id,omitempty" toml:"staff_id" yaml:"staff_id,omitempty"`
	ReservationNumber    int       `boil:"reservation_number" json:"reservation_number" toml:"reservation_number" yaml:"reservation_number"`
	ReservedDatetime     time.Time `boil:"reserved_datetime" json:"reserved_datetime" toml:"reserved_datetime" yaml:"reserved_datetime"`
	HoldStartDatetime    null.Time `boil:"hold_start_datetime" json:"hold_start_datetime,omitempty" toml:"hold_start_datetime" yaml:"hold_start_datetime,omitempty"`
	ServiceStartDatetime null.Time `boil:"service_start_datetime" json:"service_start_datetime,omitempty" toml:"service_start_datetime" yaml:"service_start_datetime,omitempty"`
	ServiceEndDatetime   null.Time `boil:"service_end_datetime" json:"service_end_datetime,omitempty" toml:"service_end_datetime" yaml:"service_end_datetime,omitempty"`
	Status               int       `boil:"status" json:"status" toml:"status" yaml:"status"`
	ArrivalFlag          bool      `boil:"arrival_flag" json:"arrival_flag" toml:"arrival_flag" yaml:"arrival_flag"`
	CancelType           null.Int  `boil:"cancel_type" json:"cancel_type,omitempty" toml:"cancel_type" yaml:"cancel_type,omitempty"`
	CreatedAt            time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt            time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedBy            null.Int  `boil:"created_by" json:"created_by,omitempty" toml:"created_by" yaml:"created_by,omitempty"`
	CreatedByType        string    `boil:"created_by_type" json:"created_by_type" toml:"created_by_type" yaml:"created_by_type"`
	UpdatedBy            null.Int  `boil:"updated_by" json:"updated_by,omitempty" toml:"updated_by" yaml:"updated_by,omitempty"`
	UpdatedByType        string    `boil:"updated_by_type" json:"updated_by_type" toml:"updated_by_type" yaml:"updated_by_type"`

	R *reservationR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L reservationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ReservationColumns = struct {
	ReservationID        string
	CustomerID           string
	StoreID              string
	StaffID              string
	ReservationNumber    string
	ReservedDatetime     string
	HoldStartDatetime    string
	ServiceStartDatetime string
	ServiceEndDatetime   string
	Status               string
	ArrivalFlag          string
	CancelType           string
	CreatedAt            string
	UpdatedAt            string
	CreatedBy            string
	CreatedByType        string
	UpdatedBy            string
	UpdatedByType        string
}{
	ReservationID:        "reservation_id",
	CustomerID:           "customer_id",
	StoreID:              "store_id",
	StaffID:              "staff_id",
	ReservationNumber:    "reservation_number",
	ReservedDatetime:     "reserved_datetime",
	HoldStartDatetime:    "hold_start_datetime",
	ServiceStartDatetime: "service_start_datetime",
	ServiceEndDatetime:   "service_end_datetime",
	Status:               "status",
	ArrivalFlag:          "arrival_flag",
	CancelType:           "cancel_type",
	CreatedAt:            "created_at",
	UpdatedAt:            "updated_at",
	CreatedBy:            "created_by",
	CreatedByType:        "created_by_type",
	UpdatedBy:            "updated_by",
	UpdatedByType:        "updated_by_type",
}

var ReservationTableColumns = struct {
	ReservationID        string
	CustomerID           string
	StoreID              string
	StaffID              string
	ReservationNumber    string
	ReservedDatetime     string
	HoldStartDatetime    string
	ServiceStartDatetime string
	ServiceEndDatetime   string
	Status               string
	ArrivalFlag          string
	CancelType           string
	CreatedAt            string
	UpdatedAt            string
	CreatedBy            string
	CreatedByType        string
	UpdatedBy            string
	UpdatedByType        string
}{
	ReservationID:        "reservations.reservation_id",
	CustomerID:           "reservations.customer_id",
	StoreID:              "reservations.store_id",
	StaffID:              "reservations.staff_id",
	ReservationNumber:    "reservations.reservation_number",
	ReservedDatetime:     "reservations.reserved_datetime",
	HoldStartDatetime:    "reservations.hold_start_datetime",
	ServiceStartDatetime: "reservations.service_start_datetime",
	ServiceEndDatetime:   "reservations.service_end_datetime",
	Status:               "reservations.status",
	ArrivalFlag:          "reservations.arrival_flag",
	CancelType:           "reservations.cancel_type",
	CreatedAt:            "reservations.created_at",
	UpdatedAt:            "reservations.updated_at",
	CreatedBy:            "reservations.created_by",
	CreatedByType:        "reservations.created_by_type",
	UpdatedBy:            "reservations.updated_by",
	UpdatedByType:        "reservations.updated_by_type",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var ReservationWhere = struct {
	ReservationID        whereHelperint
	CustomerID           whereHelperint
	StoreID              whereHelperint
	StaffID              whereHelpernull_Int
	ReservationNumber    whereHelperint
	ReservedDatetime     whereHelpertime_Time
	HoldStartDatetime    whereHelpernull_Time
	ServiceStartDatetime whereHelpernull_Time
	ServiceEndDatetime   whereHelpernull_Time
	Status               whereHelperint
	ArrivalFlag          whereHelperbool
	CancelType           whereHelpernull_Int
	CreatedAt            whereHelpertime_Time
	UpdatedAt            whereHelpertime_Time
	CreatedBy            whereHelpernull_Int
	CreatedByType        whereHelperstring
	UpdatedBy            whereHelpernull_Int
	UpdatedByType        whereHelperstring
}{
	ReservationID:        whereHelperint{field: "`reservations`.`reservation_id`"},
	CustomerID:           whereHelperint{field: "`reservations`.`customer_id`"},
	StoreID:              whereHelperint{field: "`reservations`.`store_id`"},
	StaffID:              whereHelpernull_Int{field: "`reservations`.`staff_id`"},
	ReservationNumber:    whereHelperint{field: "`reservations`.`reservation_number`"},
	ReservedDatetime:     whereHelpertime_Time{field: "`reservations`.`reserved_datetime`"},
	HoldStartDatetime:    whereHelpernull_Time{field: "`reservations`.`hold_start_datetime`"},
	ServiceStartDatetime: whereHelpernull_Time{field: "`reservations`.`service_start_datetime`"},
	ServiceEndDatetime:   whereHelpernull_Time{field: "`reservations`.`service_end_datetime`"},
	Status:               whereHelperint{field: "`reservations`.`status`"},
	ArrivalFlag:          whereHelperbool{field: "`reservations`.`arrival_flag`"},
	CancelType:           whereHelpernull_Int{field: "`reservations`.`cancel_type`"},
	CreatedAt:            whereHelpertime_Time{field: "`reservations`.`created_at`"},
	UpdatedAt:            whereHelpertime_Time{field: "`reservations`.`updated_at`"},
	CreatedBy:            whereHelpernull_Int{field: "`reservations`.`created_by`"},
	CreatedByType:        whereHelperstring{field: "`reservations`.`created_by_type`"},
	UpdatedBy:            whereHelpernull_Int{field: "`reservations`.`updated_by`"},
	UpdatedByType:        whereHelperstring{field: "`reservations`.`updated_by_type`"},
}

// ReservationRels is where relationship names are stored.
var ReservationRels = struct {
	Customer         string
	Store            string
	Staff            string
	Notifications    string
	ReservationMenus string
	VisitHistories   string
}{
	Customer:         "Customer",
	Store:            "Store",
	Staff:            "Staff",
	Notifications:    "Notifications",
	ReservationMenus: "ReservationMenus",
	VisitHistories:   "VisitHistories",
}

// reservationR is where relationships are stored.
type reservationR struct {
	Customer         *Customer            `boil:"Customer" json:"Customer" toml:"Customer" yaml:"Customer"`
	Store            *Store               `boil:"Store" json:"Store" toml:"Store" yaml:"Store"`
	Staff            *Staff               `boil:"Staff" json:"Staff" toml:"Staff" yaml:"Staff"`
	Notifications    NotificationSlice    `boil:"Notifications" json:"Notifications" toml:"Notifications" yaml:"Notifications"`
	ReservationMenus ReservationMenuSlice `boil:"ReservationMenus" json:"ReservationMenus" toml:"ReservationMenus" yaml:"ReservationMenus"`
	VisitHistories   VisitHistorySlice    `boil:"VisitHistories" json:"VisitHistories" toml:"VisitHistories" yaml:"VisitHistories"`
}

// NewStruct creates a new relationship struct
func (*reservationR) NewStruct() *reservationR {
	return &reservationR{}
}

func (r *reservationR) GetCustomer() *Customer {
	if r == nil {
		return nil
	}
	return r.Customer
}

func (r *reservationR) GetStore() *Store {
	if r == nil {
		return nil
	}
	return r.Store
}

func (r *reservationR) GetStaff() *Staff {
	if r == nil {
		return nil
	}
	return r.Staff
}

func (r *reservationR) GetNotifications() NotificationSlice {
	if r == nil {
		return nil
	}
	return r.Notifications
}

func (r *reservationR) GetReservationMenus() ReservationMenuSlice {
	if r == nil {
		return nil
	}
	return r.ReservationMenus
}

func (r *reservationR) GetVisitHistories() VisitHistorySlice {
	if r == nil {
		return nil
	}
	return r.VisitHistories
}

// reservationL is where Load methods for each relationship are stored.
type reservationL struct{}

var (
	reservationAllColumns            = []string{"reservation_id", "customer_id", "store_id", "staff_id", "reservation_number", "reserved_datetime", "hold_start_datetime", "service_start_datetime", "service_end_datetime", "status", "arrival_flag", "cancel_type", "created_at", "updated_at", "created_by", "created_by_type", "updated_by", "updated_by_type"}
	reservationColumnsWithoutDefault = []string{"customer_id", "store_id", "staff_id", "reservation_number", "reserved_datetime", "hold_start_datetime", "service_start_datetime", "service_end_datetime", "cancel_type"}
	reservationColumnsWithDefault    = []string{"reservation_id", "status", "arrival_flag", "created_at", "updated_at", "created_by", "created_by_type", "updated_by", "updated_by_type"}
	reservationPrimaryKeyColumns     = []string{"reservation_id"}
	reservationGeneratedColumns      = []string{}
)

type (
	// ReservationSlice is an alias for a slice of pointers to Reservation.
	// This should almost always be used instead of []Reservation.
	ReservationSlice []*Reservation
	// ReservationHook is the signature for custom Reservation hook methods
	ReservationHook func(context.Context, boil.ContextExecutor, *Reservation) error

	reservationQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	reservationType                 = reflect.TypeOf(&Reservation{})
	reservationMapping              = queries.MakeStructMapping(reservationType)
	reservationPrimaryKeyMapping, _ = queries.BindMapping(reservationType, reservationMapping, reservationPrimaryKeyColumns)
	reservationInsertCacheMut       sync.RWMutex
	reservationInsertCache          = make(map[string]insertCache)
	reservationUpdateCacheMut       sync.RWMutex
	reservationUpdateCache          = make(map[string]updateCache)
	reservationUpsertCacheMut       sync.RWMutex
	reservationUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var reservationAfterSelectHooks []ReservationHook

var reservationBeforeInsertHooks []ReservationHook
var reservationAfterInsertHooks []ReservationHook

var reservationBeforeUpdateHooks []ReservationHook
var reservationAfterUpdateHooks []ReservationHook

var reservationBeforeDeleteHooks []ReservationHook
var reservationAfterDeleteHooks []ReservationHook

var reservationBeforeUpsertHooks []ReservationHook
var reservationAfterUpsertHooks []ReservationHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Reservation) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Reservation) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Reservation) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Reservation) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Reservation) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Reservation) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Reservation) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Reservation) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Reservation) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range reservationAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddReservationHook registers your hook function for all future operations.
func AddReservationHook(hookPoint boil.HookPoint, reservationHook ReservationHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		reservationAfterSelectHooks = append(reservationAfterSelectHooks, reservationHook)
	case boil.BeforeInsertHook:
		reservationBeforeInsertHooks = append(reservationBeforeInsertHooks, reservationHook)
	case boil.AfterInsertHook:
		reservationAfterInsertHooks = append(reservationAfterInsertHooks, reservationHook)
	case boil.BeforeUpdateHook:
		reservationBeforeUpdateHooks = append(reservationBeforeUpdateHooks, reservationHook)
	case boil.AfterUpdateHook:
		reservationAfterUpdateHooks = append(reservationAfterUpdateHooks, reservationHook)
	case boil.BeforeDeleteHook:
		reservationBeforeDeleteHooks = append(reservationBeforeDeleteHooks, reservationHook)
	case boil.AfterDeleteHook:
		reservationAfterDeleteHooks = append(reservationAfterDeleteHooks, reservationHook)
	case boil.BeforeUpsertHook:
		reservationBeforeUpsertHooks = append(reservationBeforeUpsertHooks, reservationHook)
	case boil.AfterUpsertHook:
		reservationAfterUpsertHooks = append(reservationAfterUpsertHooks, reservationHook)
	}
}

// OneG returns a single reservation record from the query using the global executor.
func (q reservationQuery) OneG(ctx context.Context) (*Reservation, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single reservation record from the query.
func (q reservationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Reservation, error) {
	o := &Reservation{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for reservations")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Reservation records from the query using the global executor.
func (q reservationQuery) AllG(ctx context.Context) (ReservationSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Reservation records from the query.
func (q reservationQuery) All(ctx context.Context, exec boil.ContextExecutor) (ReservationSlice, error) {
	var o []*Reservation

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Reservation slice")
	}

	if len(reservationAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Reservation records in the query using the global executor
func (q reservationQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Reservation records in the query.
func (q reservationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count reservations rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q reservationQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q reservationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if reservations exists")
	}

	return count > 0, nil
}

// Customer pointed to by the foreign key.
func (o *Reservation) Customer(mods ...qm.QueryMod) customerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`customer_id` = ?", o.CustomerID),
	}

	queryMods = append(queryMods, mods...)

	return Customers(queryMods...)
}

// Store pointed to by the foreign key.
func (o *Reservation) Store(mods ...qm.QueryMod) storeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`store_id` = ?", o.StoreID),
	}

	queryMods = append(queryMods, mods...)

	return Stores(queryMods...)
}

// Staff pointed to by the foreign key.
func (o *Reservation) Staff(mods ...qm.QueryMod) staffQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`staff_id` = ?", o.StaffID),
	}

	queryMods = append(queryMods, mods...)

	return Staffs(queryMods...)
}

// Notifications retrieves all the notification's Notifications with an executor.
func (o *Reservation) Notifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`notifications`.`reservation_id`=?", o.ReservationID),
	)

	return Notifications(queryMods...)
}

// ReservationMenus retrieves all the reservation_menu's ReservationMenus with an executor.
func (o *Reservation) ReservationMenus(mods ...qm.QueryMod) reservationMenuQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`reservation_menus`.`reservation_id`=?", o.ReservationID),
	)

	return ReservationMenus(queryMods...)
}

// VisitHistories retrieves all the visit_history's VisitHistories with an executor.
func (o *Reservation) VisitHistories(mods ...qm.QueryMod) visitHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`visit_history`.`reservation_id`=?", o.ReservationID),
	)

	return VisitHistories(queryMods...)
}

// LoadCustomer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (reservationL) LoadCustomer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		args = append(args, object.CustomerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if a == obj.CustomerID {
					continue Outer
				}
			}

			args = append(args, obj.CustomerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customers`),
		qm.WhereIn(`customers.customer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Customer")
	}

	var resultSlice []*Customer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Customer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for customers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customers")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Customer = foreign
		if foreign.R == nil {
			foreign.R = &customerR{}
		}
		foreign.R.Reservations = append(foreign.R.Reservations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CustomerID == foreign.CustomerID {
				local.R.Customer = foreign
				if foreign.R == nil {
					foreign.R = &customerR{}
				}
				foreign.R.Reservations = append(foreign.R.Reservations, local)
				break
			}
		}
	}

	return nil
}

// LoadStore allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (reservationL) LoadStore(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		args = append(args, object.StoreID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if a == obj.StoreID {
					continue Outer
				}
			}

			args = append(args, obj.StoreID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`stores`),
		qm.WhereIn(`stores.store_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Store")
	}

	var resultSlice []*Store
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Store")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for stores")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for stores")
	}

	if len(storeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Store = foreign
		if foreign.R == nil {
			foreign.R = &storeR{}
		}
		foreign.R.Reservations = append(foreign.R.Reservations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.StoreID == foreign.StoreID {
				local.R.Store = foreign
				if foreign.R == nil {
					foreign.R = &storeR{}
				}
				foreign.R.Reservations = append(foreign.R.Reservations, local)
				break
			}
		}
	}

	return nil
}

// LoadStaff allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (reservationL) LoadStaff(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		if !queries.IsNil(object.StaffID) {
			args = append(args, object.StaffID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.StaffID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.StaffID) {
				args = append(args, obj.StaffID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`staffs`),
		qm.WhereIn(`staffs.staff_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Staff")
	}

	var resultSlice []*Staff
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Staff")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for staffs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staffs")
	}

	if len(staffAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Staff = foreign
		if foreign.R == nil {
			foreign.R = &staffR{}
		}
		foreign.R.Reservations = append(foreign.R.Reservations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.StaffID, foreign.StaffID) {
				local.R.Staff = foreign
				if foreign.R == nil {
					foreign.R = &staffR{}
				}
				foreign.R.Reservations = append(foreign.R.Reservations, local)
				break
			}
		}
	}

	return nil
}

// LoadNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (reservationL) LoadNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		args = append(args, object.ReservationID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ReservationID) {
					continue Outer
				}
			}

			args = append(args, obj.ReservationID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notifications`),
		qm.WhereIn(`notifications.reservation_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notifications")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notifications")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notifications")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notifications")
	}

	if len(notificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Notifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.Reservation = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ReservationID, foreign.ReservationID) {
				local.R.Notifications = append(local.R.Notifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.Reservation = local
				break
			}
		}
	}

	return nil
}

// LoadReservationMenus allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (reservationL) LoadReservationMenus(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		args = append(args, object.ReservationID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if a == obj.ReservationID {
					continue Outer
				}
			}

			args = append(args, obj.ReservationID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`reservation_menus`),
		qm.WhereIn(`reservation_menus.reservation_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load reservation_menus")
	}

	var resultSlice []*ReservationMenu
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice reservation_menus")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on reservation_menus")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for reservation_menus")
	}

	if len(reservationMenuAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReservationMenus = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &reservationMenuR{}
			}
			foreign.R.Reservation = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ReservationID == foreign.ReservationID {
				local.R.ReservationMenus = append(local.R.ReservationMenus, foreign)
				if foreign.R == nil {
					foreign.R = &reservationMenuR{}
				}
				foreign.R.Reservation = local
				break
			}
		}
	}

	return nil
}

// LoadVisitHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (reservationL) LoadVisitHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeReservation interface{}, mods queries.Applicator) error {
	var slice []*Reservation
	var object *Reservation

	if singular {
		var ok bool
		object, ok = maybeReservation.(*Reservation)
		if !ok {
			object = new(Reservation)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeReservation))
			}
		}
	} else {
		s, ok := maybeReservation.(*[]*Reservation)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeReservation)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeReservation))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &reservationR{}
		}
		args = append(args, object.ReservationID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &reservationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ReservationID) {
					continue Outer
				}
			}

			args = append(args, obj.ReservationID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`visit_history`),
		qm.WhereIn(`visit_history.reservation_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load visit_history")
	}

	var resultSlice []*VisitHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice visit_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on visit_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for visit_history")
	}

	if len(visitHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VisitHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &visitHistoryR{}
			}
			foreign.R.Reservation = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ReservationID, foreign.ReservationID) {
				local.R.VisitHistories = append(local.R.VisitHistories, foreign)
				if foreign.R == nil {
					foreign.R = &visitHistoryR{}
				}
				foreign.R.Reservation = local
				break
			}
		}
	}

	return nil
}

// SetCustomerG of the reservation to the related item.
// Sets o.R.Customer to related.
// Adds o to related.R.Reservations.
// Uses the global database handle.
func (o *Reservation) SetCustomerG(ctx context.Context, insert bool, related *Customer) error {
	return o.SetCustomer(ctx, boil.GetContextDB(), insert, related)
}

// SetCustomer of the reservation to the related item.
// Sets o.R.Customer to related.
// Adds o to related.R.Reservations.
func (o *Reservation) SetCustomer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Customer) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `reservations` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
		strmangle.WhereClause("`", "`", 0, reservationPrimaryKeyColumns),
	)
	values := []interface{}{related.CustomerID, o.ReservationID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CustomerID = related.CustomerID
	if o.R == nil {
		o.R = &reservationR{
			Customer: related,
		}
	} else {
		o.R.Customer = related
	}

	if related.R == nil {
		related.R = &customerR{
			Reservations: ReservationSlice{o},
		}
	} else {
		related.R.Reservations = append(related.R.Reservations, o)
	}

	return nil
}

// SetStoreG of the reservation to the related item.
// Sets o.R.Store to related.
// Adds o to related.R.Reservations.
// Uses the global database handle.
func (o *Reservation) SetStoreG(ctx context.Context, insert bool, related *Store) error {
	return o.SetStore(ctx, boil.GetContextDB(), insert, related)
}

// SetStore of the reservation to the related item.
// Sets o.R.Store to related.
// Adds o to related.R.Reservations.
func (o *Reservation) SetStore(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Store) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `reservations` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"store_id"}),
		strmangle.WhereClause("`", "`", 0, reservationPrimaryKeyColumns),
	)
	values := []interface{}{related.StoreID, o.ReservationID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.StoreID = related.StoreID
	if o.R == nil {
		o.R = &reservationR{
			Store: related,
		}
	} else {
		o.R.Store = related
	}

	if related.R == nil {
		related.R = &storeR{
			Reservations: ReservationSlice{o},
		}
	} else {
		related.R.Reservations = append(related.R.Reservations, o)
	}

	return nil
}

// SetStaffG of the reservation to the related item.
// Sets o.R.Staff to related.
// Adds o to related.R.Reservations.
// Uses the global database handle.
func (o *Reservation) SetStaffG(ctx context.Context, insert bool, related *Staff) error {
	return o.SetStaff(ctx, boil.GetContextDB(), insert, related)
}

// SetStaff of the reservation to the related item.
// Sets o.R.Staff to related.
// Adds o to related.R.Reservations.
func (o *Reservation) SetStaff(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Staff) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `reservations` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"staff_id"}),
		strmangle.WhereClause("`", "`", 0, reservationPrimaryKeyColumns),
	)
	values := []interface{}{related.StaffID, o.ReservationID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.StaffID, related.StaffID)
	if o.R == nil {
		o.R = &reservationR{
			Staff: related,
		}
	} else {
		o.R.Staff = related
	}

	if related.R == nil {
		related.R = &staffR{
			Reservations: ReservationSlice{o},
		}
	} else {
		related.R.Reservations = append(related.R.Reservations, o)
	}

	return nil
}

// RemoveStaffG relationship.
// Sets o.R.Staff to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Reservation) RemoveStaffG(ctx context.Context, related *Staff) error {
	return o.RemoveStaff(ctx, boil.GetContextDB(), related)
}

// RemoveStaff relationship.
// Sets o.R.Staff to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Reservation) RemoveStaff(ctx context.Context, exec boil.ContextExecutor, related *Staff) error {
	var err error

	queries.SetScanner(&o.StaffID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("staff_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Staff = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Reservations {
		if queries.Equal(o.StaffID, ri.StaffID) {
			continue
		}

		ln := len(related.R.Reservations)
		if ln > 1 && i < ln-1 {
			related.R.Reservations[i] = related.R.Reservations[ln-1]
		}
		related.R.Reservations = related.R.Reservations[:ln-1]
		break
	}
	return nil
}

// AddNotificationsG adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.Notifications.
// Sets related.R.Reservation appropriately.
// Uses the global database handle.
func (o *Reservation) AddNotificationsG(ctx context.Context, insert bool, related ...*Notification) error {
	return o.AddNotifications(ctx, boil.GetContextDB(), insert, related...)
}

// AddNotifications adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.Notifications.
// Sets related.R.Reservation appropriately.
func (o *Reservation) AddNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ReservationID, o.ReservationID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `notifications` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reservation_id"}),
				strmangle.WhereClause("`", "`", 0, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ReservationID, rel.NotificationID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ReservationID, o.ReservationID)
		}
	}

	if o.R == nil {
		o.R = &reservationR{
			Notifications: related,
		}
	} else {
		o.R.Notifications = append(o.R.Notifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				Reservation: o,
			}
		} else {
			rel.R.Reservation = o
		}
	}
	return nil
}

// SetNotificationsG removes all previously related items of the
// reservation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Reservation's Notifications accordingly.
// Replaces o.R.Notifications with related.
// Sets related.R.Reservation's Notifications accordingly.
// Uses the global database handle.
func (o *Reservation) SetNotificationsG(ctx context.Context, insert bool, related ...*Notification) error {
	return o.SetNotifications(ctx, boil.GetContextDB(), insert, related...)
}

// SetNotifications removes all previously related items of the
// reservation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Reservation's Notifications accordingly.
// Replaces o.R.Notifications with related.
// Sets related.R.Reservation's Notifications accordingly.
func (o *Reservation) SetNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	query := "update `notifications` set `reservation_id` = null where `reservation_id` = ?"
	values := []interface{}{o.ReservationID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Notifications {
			queries.SetScanner(&rel.ReservationID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Reservation = nil
		}
		o.R.Notifications = nil
	}

	return o.AddNotifications(ctx, exec, insert, related...)
}

// RemoveNotificationsG relationships from objects passed in.
// Removes related items from R.Notifications (uses pointer comparison, removal does not keep order)
// Sets related.R.Reservation.
// Uses the global database handle.
func (o *Reservation) RemoveNotificationsG(ctx context.Context, related ...*Notification) error {
	return o.RemoveNotifications(ctx, boil.GetContextDB(), related...)
}

// RemoveNotifications relationships from objects passed in.
// Removes related items from R.Notifications (uses pointer comparison, removal does not keep order)
// Sets related.R.Reservation.
func (o *Reservation) RemoveNotifications(ctx context.Context, exec boil.ContextExecutor, related ...*Notification) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ReservationID, nil)
		if rel.R != nil {
			rel.R.Reservation = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("reservation_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Notifications {
			if rel != ri {
				continue
			}

			ln := len(o.R.Notifications)
			if ln > 1 && i < ln-1 {
				o.R.Notifications[i] = o.R.Notifications[ln-1]
			}
			o.R.Notifications = o.R.Notifications[:ln-1]
			break
		}
	}

	return nil
}

// AddReservationMenusG adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.ReservationMenus.
// Sets related.R.Reservation appropriately.
// Uses the global database handle.
func (o *Reservation) AddReservationMenusG(ctx context.Context, insert bool, related ...*ReservationMenu) error {
	return o.AddReservationMenus(ctx, boil.GetContextDB(), insert, related...)
}

// AddReservationMenus adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.ReservationMenus.
// Sets related.R.Reservation appropriately.
func (o *Reservation) AddReservationMenus(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReservationMenu) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReservationID = o.ReservationID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `reservation_menus` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reservation_id"}),
				strmangle.WhereClause("`", "`", 0, reservationMenuPrimaryKeyColumns),
			)
			values := []interface{}{o.ReservationID, rel.ReservationID, rel.StoreID, rel.MenuID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReservationID = o.ReservationID
		}
	}

	if o.R == nil {
		o.R = &reservationR{
			ReservationMenus: related,
		}
	} else {
		o.R.ReservationMenus = append(o.R.ReservationMenus, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &reservationMenuR{
				Reservation: o,
			}
		} else {
			rel.R.Reservation = o
		}
	}
	return nil
}

// AddVisitHistoriesG adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.VisitHistories.
// Sets related.R.Reservation appropriately.
// Uses the global database handle.
func (o *Reservation) AddVisitHistoriesG(ctx context.Context, insert bool, related ...*VisitHistory) error {
	return o.AddVisitHistories(ctx, boil.GetContextDB(), insert, related...)
}

// AddVisitHistories adds the given related objects to the existing relationships
// of the reservation, optionally inserting them as new records.
// Appends related to o.R.VisitHistories.
// Sets related.R.Reservation appropriately.
func (o *Reservation) AddVisitHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VisitHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ReservationID, o.ReservationID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `visit_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"reservation_id"}),
				strmangle.WhereClause("`", "`", 0, visitHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ReservationID, rel.VisitHistoryID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ReservationID, o.ReservationID)
		}
	}

	if o.R == nil {
		o.R = &reservationR{
			VisitHistories: related,
		}
	} else {
		o.R.VisitHistories = append(o.R.VisitHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &visitHistoryR{
				Reservation: o,
			}
		} else {
			rel.R.Reservation = o
		}
	}
	return nil
}

// SetVisitHistoriesG removes all previously related items of the
// reservation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Reservation's VisitHistories accordingly.
// Replaces o.R.VisitHistories with related.
// Sets related.R.Reservation's VisitHistories accordingly.
// Uses the global database handle.
func (o *Reservation) SetVisitHistoriesG(ctx context.Context, insert bool, related ...*VisitHistory) error {
	return o.SetVisitHistories(ctx, boil.GetContextDB(), insert, related...)
}

// SetVisitHistories removes all previously related items of the
// reservation replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Reservation's VisitHistories accordingly.
// Replaces o.R.VisitHistories with related.
// Sets related.R.Reservation's VisitHistories accordingly.
func (o *Reservation) SetVisitHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VisitHistory) error {
	query := "update `visit_history` set `reservation_id` = null where `reservation_id` = ?"
	values := []interface{}{o.ReservationID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.VisitHistories {
			queries.SetScanner(&rel.ReservationID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Reservation = nil
		}
		o.R.VisitHistories = nil
	}

	return o.AddVisitHistories(ctx, exec, insert, related...)
}

// RemoveVisitHistoriesG relationships from objects passed in.
// Removes related items from R.VisitHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Reservation.
// Uses the global database handle.
func (o *Reservation) RemoveVisitHistoriesG(ctx context.Context, related ...*VisitHistory) error {
	return o.RemoveVisitHistories(ctx, boil.GetContextDB(), related...)
}

// RemoveVisitHistories relationships from objects passed in.
// Removes related items from R.VisitHistories (uses pointer comparison, removal does not keep order)
// Sets related.R.Reservation.
func (o *Reservation) RemoveVisitHistories(ctx context.Context, exec boil.ContextExecutor, related ...*VisitHistory) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ReservationID, nil)
		if rel.R != nil {
			rel.R.Reservation = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("reservation_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.VisitHistories {
			if rel != ri {
				continue
			}

			ln := len(o.R.VisitHistories)
			if ln > 1 && i < ln-1 {
				o.R.VisitHistories[i] = o.R.VisitHistories[ln-1]
			}
			o.R.VisitHistories = o.R.VisitHistories[:ln-1]
			break
		}
	}

	return nil
}

// Reservations retrieves all the records using an executor.
func Reservations(mods ...qm.QueryMod) reservationQuery {
	mods = append(mods, qm.From("`reservations`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`reservations`.*"})
	}

	return reservationQuery{q}
}

// FindReservationG retrieves a single record by ID.
func FindReservationG(ctx context.Context, reservationID int, selectCols ...string) (*Reservation, error) {
	return FindReservation(ctx, boil.GetContextDB(), reservationID, selectCols...)
}

// FindReservation retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindReservation(ctx context.Context, exec boil.ContextExecutor, reservationID int, selectCols ...string) (*Reservation, error) {
	reservationObj := &Reservation{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `reservations` where `reservation_id`=?", sel,
	)

	q := queries.Raw(query, reservationID)

	err := q.Bind(ctx, exec, reservationObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from reservations")
	}

	if err = reservationObj.doAfterSelectHooks(ctx, exec); err != nil {
		return reservationObj, err
	}

	return reservationObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Reservation) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Reservation) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no reservations provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(reservationColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	reservationInsertCacheMut.RLock()
	cache, cached := reservationInsertCache[key]
	reservationInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			reservationAllColumns,
			reservationColumnsWithDefault,
			reservationColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(reservationType, reservationMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(reservationType, reservationMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `reservations` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `reservations` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `reservations` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, reservationPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into reservations")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ReservationID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == reservationMapping["reservation_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ReservationID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for reservations")
	}

CacheNoHooks:
	if !cached {
		reservationInsertCacheMut.Lock()
		reservationInsertCache[key] = cache
		reservationInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Reservation record using the global executor.
// See Update for more documentation.
func (o *Reservation) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Reservation.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Reservation) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	reservationUpdateCacheMut.RLock()
	cache, cached := reservationUpdateCache[key]
	reservationUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			reservationAllColumns,
			reservationPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update reservations, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `reservations` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, reservationPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(reservationType, reservationMapping, append(wl, reservationPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update reservations row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for reservations")
	}

	if !cached {
		reservationUpdateCacheMut.Lock()
		reservationUpdateCache[key] = cache
		reservationUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q reservationQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q reservationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for reservations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for reservations")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ReservationSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ReservationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), reservationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `reservations` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, reservationPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in reservation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all reservation")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Reservation) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

var mySQLReservationUniqueColumns = []string{
	"reservation_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Reservation) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no reservations provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(reservationColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLReservationUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	reservationUpsertCacheMut.RLock()
	cache, cached := reservationUpsertCache[key]
	reservationUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			reservationAllColumns,
			reservationColumnsWithDefault,
			reservationColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			reservationAllColumns,
			reservationPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert reservations, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`reservations`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `reservations` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(reservationType, reservationMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(reservationType, reservationMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for reservations")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ReservationID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == reservationMapping["reservation_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(reservationType, reservationMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for reservations")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for reservations")
	}

CacheNoHooks:
	if !cached {
		reservationUpsertCacheMut.Lock()
		reservationUpsertCache[key] = cache
		reservationUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Reservation record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Reservation) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Reservation record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Reservation) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Reservation provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), reservationPrimaryKeyMapping)
	sql := "DELETE FROM `reservations` WHERE `reservation_id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from reservations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for reservations")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q reservationQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q reservationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no reservationQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from reservations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for reservations")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ReservationSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ReservationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(reservationBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), reservationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `reservations` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, reservationPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from reservation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for reservations")
	}

	if len(reservationAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Reservation) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no Reservation provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Reservation) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindReservation(ctx, exec, o.ReservationID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ReservationSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty ReservationSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ReservationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ReservationSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), reservationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `reservations`.* FROM `reservations` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, reservationPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ReservationSlice")
	}

	*o = slice

	return nil
}

// ReservationExistsG checks if the Reservation row exists.
func ReservationExistsG(ctx context.Context, reservationID int) (bool, error) {
	return ReservationExists(ctx, boil.GetContextDB(), reservationID)
}

// ReservationExists checks if the Reservation row exists.
func ReservationExists(ctx context.Context, exec boil.ContextExecutor, reservationID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `reservations` where `reservation_id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, reservationID)
	}
	row := exec.QueryRowContext(ctx, sql, reservationID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if reservations exists")
	}

	return exists, nil
}

// Exists checks if the Reservation row exists.
func (o *Reservation) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ReservationExists(ctx, exec, o.ReservationID)
}
